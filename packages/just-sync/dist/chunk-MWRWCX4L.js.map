{"version":3,"sources":["../src/index.ts"],"sourcesContent":["export type PrimaryKey = string | number | Record<string, string | number>;\nexport type OrderBy = Record<string, 'asc' | 'desc'>;\nexport type SelectWindow = {\n  select?: string[];\n  orderBy?: OrderBy;\n  limit?: number;\n  cursor?: string | null;\n};\n\nexport type MutationOp =\n  | { op: 'insert'; table: string; rows: Record<string, unknown> | Record<string, unknown>[] }\n  | { op: 'update'; table: string; pk: PrimaryKey; set: Record<string, unknown>; ifVersion?: number }\n  | { op: 'updateWhere'; table: string; where: unknown; set: Record<string, unknown> }\n  | { op: 'delete'; table: string; pk: PrimaryKey }\n  | { op: 'deleteWhere'; table: string; where: unknown }\n  | { op: 'upsert'; table: string; rows: Record<string, unknown> | Record<string, unknown>[]; merge?: string[] };\n\nexport type MutationRequest = MutationOp & { clientOpId?: string };\nexport type MutationResponse =\n  | { row: Record<string, unknown> }\n  | { rows: Record<string, unknown>[] }\n  | { ok: true }\n  | { ok: number; failed: Array<{ pk: PrimaryKey; error: { code: string; message: string } }>; pks: PrimaryKey[] };\n\nexport type SelectRequest = {\n  table: string;\n  where?: unknown;\n  select?: string[];\n  orderBy?: OrderBy;\n  limit?: number;\n  cursor?: string | null;\n};\nexport type SelectResponse = { data: Record<string, unknown>[]; nextCursor?: string | null };\n\nexport type SseEvent = {\n  eventId: string;\n  txId: string;\n  tables: Array<{\n    name: string;\n    type: 'mutation';\n    pks: PrimaryKey[];\n    rowVersions?: Record<string, number>;\n    diffs?: Record<string, { set?: Record<string, unknown>; unset?: string[] }>;\n  }>;\n};\n\nexport interface DatabaseAdapter {\n  begin(): Promise<void>;\n  commit(): Promise<void>;\n  rollback(): Promise<void>;\n  insert(table: string, row: Record<string, unknown>): Promise<Record<string, unknown>>;\n  updateByPk(table: string, pk: PrimaryKey, set: Record<string, unknown>, opts?: { ifVersion?: number }): Promise<Record<string, unknown>>;\n  deleteByPk(table: string, pk: PrimaryKey): Promise<{ ok: true }>;\n  selectByPk(table: string, pk: PrimaryKey, select?: string[]): Promise<Record<string, unknown> | null>;\n  selectWindow(table: string, req: SelectWindow & { where?: unknown }): Promise<{ data: Record<string, unknown>[]; nextCursor?: string | null }>;\n}\n\nexport interface ClientDatastore {\n  apply(table: string, pk: PrimaryKey, diff: { set?: Record<string, unknown>; unset?: string[] }): Promise<void>;\n  reconcile(table: string, pk: PrimaryKey, row: Record<string, unknown> & { version: number }): Promise<void>;\n  readByPk(table: string, pk: PrimaryKey, select?: string[]): Promise<Record<string, unknown> | null>;\n  readWindow(table: string, req: SelectWindow & { where?: unknown }): Promise<{ data: Record<string, unknown>[]; nextCursor?: string | null }>;\n}\n\nexport interface IdempotencyStore {\n  get(key: string): Promise<{ status: 'hit'; response: unknown } | { status: 'miss' }>;\n  set(key: string, response: unknown, ttlMs: number): Promise<void>;\n  acquire?(key: string, ttlMs: number): Promise<{ ok: true } | { ok: false }>;\n  release?(key: string): Promise<void>;\n}\n\nexport type MutatorDef<Args, Result> = {\n  args?: unknown;\n  handler(ctx: { db: DatabaseAdapter; ctx: Record<string, unknown> }, args: Args): Promise<Result>;\n};\nexport type Mutators = Record<string, MutatorDef<any, any>>;\n\nexport type CreateSyncOptions = {\n  schema: Record<string, unknown>;\n  database: DatabaseAdapter;\n  mutators?: Mutators;\n  idempotency?: IdempotencyStore;\n  sse?: { bufferSeconds?: number; bufferMaxEvents?: number; heartbeatMs?: number };\n};\n\nexport type SyncInstance = {\n  handler: (req: Request) => Promise<Response>;\n  fetch: (req: Request) => Promise<Response>;\n  defineMutators(m: Mutators): Mutators;\n  $mutators: Mutators;\n};\n\n// Simple ULID fallbacks for event/tx ids\nimport { ulid } from 'ulid';\n\nclass RingBuffer<T> {\n  private buffer: Array<{ id: string; value: T }> = [];\n  constructor(private maxAgeMs: number, private maxEvents: number) {}\n  push(value: T) {\n    const id = ulid();\n    const now = Date.now();\n    this.buffer.push({ id, value });\n    // drop old by time\n    const cutoff = now - this.maxAgeMs;\n    // nothing to check by timestamp inside T; we prune by count and age using insertion time approximated by ulid monotonicity\n    while (this.buffer.length > this.maxEvents) this.buffer.shift();\n    // no precise timestamp; keep size-based for MVP\n    return id;\n  }\n  since(lastId?: string) {\n    if (!lastId) return this.buffer.slice();\n    const idx = this.buffer.findIndex((e) => e.id === lastId);\n    if (idx === -1) return this.buffer.slice();\n    return this.buffer.slice(idx + 1);\n  }\n}\n\nfunction json(data: unknown, init?: ResponseInit) {\n  return new Response(JSON.stringify(data), {\n    headers: { 'content-type': 'application/json' },\n    ...init,\n  });\n}\n\nfunction error(code: 'BAD_REQUEST' | 'UNAUTHORIZED' | 'NOT_FOUND' | 'CONFLICT' | 'INTERNAL', message: string, details?: unknown, init?: ResponseInit) {\n  return json({ code, message, details }, { status: init?.status ?? (code === 'BAD_REQUEST' ? 400 : code === 'UNAUTHORIZED' ? 401 : code === 'NOT_FOUND' ? 404 : code === 'CONFLICT' ? 409 : 500) });\n}\n\nexport function createSync(opts: CreateSyncOptions): SyncInstance {\n  const mutators: Mutators = { ...(opts.mutators ?? {}) };\n  const idStore: IdempotencyStore = opts.idempotency ?? {\n    async get() { return { status: 'miss' }; },\n    async set() { return; },\n  };\n  const buffer = new RingBuffer<SseEvent>(\n    (opts.sse?.bufferSeconds ?? 60) * 1000,\n    opts.sse?.bufferMaxEvents ?? 10000\n  );\n\n  async function handleEvents(req: Request): Promise<Response> {\n    const last = req.headers.get('last-event-id') || undefined;\n    const stream = new ReadableStream<Uint8Array>({\n      start(controller) {\n        const enc = new TextEncoder();\n        // send backlog\n        const back = buffer.since(last);\n        for (const e of back) {\n          controller.enqueue(enc.encode(`id: ${e.id}\\n`));\n          controller.enqueue(enc.encode(`event: mutation\\n`));\n          controller.enqueue(enc.encode(`data: ${JSON.stringify((e as any).value ?? e)}\\n\\n`));\n        }\n        const heartbeatMs = opts.sse?.heartbeatMs ?? 15000;\n        const iv = setInterval(() => controller.enqueue(enc.encode(`:keepalive\\n\\n`)), heartbeatMs);\n        (controller as any)._iv = iv;\n      },\n      cancel() {\n        const iv = (this as any)._iv as ReturnType<typeof setInterval> | undefined;\n        if (iv) clearInterval(iv);\n      },\n    });\n    return new Response(stream, {\n      headers: {\n        'content-type': 'text/event-stream',\n        'cache-control': 'no-cache',\n        connection: 'keep-alive',\n      },\n    });\n  }\n\n  async function handleSelect(body: SelectRequest): Promise<Response> {\n    try {\n      const limit = Math.min(1000, Math.max(1, body.limit ?? 100));\n      const orderBy = body.orderBy ?? { updatedAt: 'desc' };\n      const res = await opts.database.selectWindow(body.table, { select: body.select, orderBy, limit, cursor: body.cursor ?? null, where: body.where });\n      return json({ data: res.data, nextCursor: res.nextCursor ?? null });\n    } catch (e) {\n      return error('INTERNAL', 'Unhandled select error');\n    }\n  }\n\n  async function runMutation(op: MutationRequest): Promise<MutationResponse> {\n    switch (op.op) {\n      case 'insert': {\n        const rows = Array.isArray(op.rows) ? op.rows : [op.rows];\n        const inserted: Record<string, unknown>[] = [];\n        await opts.database.begin();\n        try {\n          for (const r of rows) {\n            inserted.push(await opts.database.insert(op.table, r));\n          }\n          await opts.database.commit();\n        } catch (e) {\n          await opts.database.rollback();\n          throw e;\n        }\n        if (Array.isArray(op.rows)) return { rows: inserted };\n        return { row: inserted[0]! };\n      }\n      case 'update': {\n        const row = await opts.database.updateByPk(op.table, op.pk, op.set, { ifVersion: op.ifVersion });\n        return { row };\n      }\n      case 'delete': {\n        await opts.database.deleteByPk(op.table, op.pk);\n        return { ok: true };\n      }\n      case 'upsert': {\n        const rows = Array.isArray(op.rows) ? op.rows : [op.rows];\n        const results: Record<string, unknown>[] = [];\n        await opts.database.begin();\n        try {\n          for (const r of rows) {\n            // naive: try insert, on conflict update by pk via updateByPk if pk exists\n            try {\n              results.push(await opts.database.insert(op.table, r));\n            } catch {\n              // fallback requires pk in payload\n              const pk = (r as any).id ?? r;\n              results.push(await opts.database.updateByPk(op.table, pk, r, {}));\n            }\n          }\n          await opts.database.commit();\n        } catch (e) {\n          await opts.database.rollback();\n          throw e;\n        }\n        if (Array.isArray(op.rows)) return { rows: results };\n        return { row: results[0]! };\n      }\n      case 'updateWhere':\n      case 'deleteWhere': {\n        // MVP: client should resolve where -> pks; server returns not implemented\n        throw Object.assign(new Error('updateWhere/deleteWhere require client-resolved PKs in MVP'), { code: 'BAD_REQUEST' });\n      }\n      default:\n        throw Object.assign(new Error('Unknown op'), { code: 'BAD_REQUEST' });\n    }\n  }\n\n  async function handleMutate(body: MutationRequest): Promise<Response> {\n    const idemKey = body.clientOpId ? `op:${body.clientOpId}` : null;\n    if (idemKey) {\n      const g = await idStore.get(idemKey);\n      if (g.status === 'hit') return json(g.response);\n    }\n    try {\n      const res = await runMutation(body);\n      // emit minimal SSE event without diffs for MVP\n      const event: SseEvent = {\n        eventId: '',\n        txId: ulid(),\n        tables: [{ name: body.table, type: 'mutation', pks: 'pk' in body ? [body.pk] : [] }],\n      } as any;\n      const eid = buffer.push(event);\n      event.eventId = eid;\n      if (idemKey) await idStore.set(idemKey, res, 10 * 60 * 1000);\n      return json(res);\n    } catch (e: any) {\n      if (e && e.code === 'BAD_REQUEST') return error('BAD_REQUEST', e.message);\n      if (e && e.code === 'CONFLICT') return error('CONFLICT', e.message, e.details);\n      return error('INTERNAL', 'Unhandled mutate error');\n    }\n  }\n\n  async function handleMutator(name: string, body: { args: unknown; clientOpId?: string }): Promise<Response> {\n    const m = mutators[name];\n    if (!m) return error('NOT_FOUND', `Mutator ${name} not found`);\n    // no runtime validator in MVP core; user can pass zod schema in args field for future enhancement\n    try {\n      const result = await m.handler({ db: opts.database, ctx: {} }, body.args as any);\n      // emit no event by default; mutators should write via db to trigger events\n      return json({ result });\n    } catch (e: any) {\n      return error('INTERNAL', e?.message || 'Mutator error');\n    }\n  }\n\n  async function handler(req: Request): Promise<Response> {\n    const url = new URL(req.url);\n    if (req.method === 'GET' && url.pathname.endsWith('/events')) return handleEvents(req);\n    if (req.method === 'POST' && url.pathname.endsWith('/select')) {\n      const body = (await req.json()) as SelectRequest;\n      return handleSelect(body);\n    }\n    if (req.method === 'POST' && url.pathname.endsWith('/mutate')) {\n      const body = (await req.json()) as MutationRequest;\n      return handleMutate(body);\n    }\n    if (req.method === 'POST' && url.pathname.includes('/mutators/')) {\n      const name = url.pathname.split('/').pop()!;\n      const body = (await req.json()) as { args: unknown; clientOpId?: string };\n      return handleMutator(name, body);\n    }\n    return error('NOT_FOUND', 'Route not found');\n  }\n\n  return {\n    handler,\n    fetch: handler,\n    defineMutators(m) {\n      Object.assign(mutators, m);\n      return mutators;\n    },\n    $mutators: mutators,\n  };\n}\n\nexport type CreateClientOptions<AppTypes extends { Schema?: any; Mutators?: any } | undefined = undefined> = {\n  baseURL: string;\n  realtime?: 'sse' | 'poll' | 'off';\n  pollIntervalMs?: number;\n  datastore?: ClientDatastore;\n};\n\ntype InferTables<S> = S extends Record<string, any> ? keyof S : string;\n\nexport function createClient<AppTypes extends { Schema?: any; Mutators?: any } | undefined = undefined>(opts: CreateClientOptions<AppTypes>) {\n  const baseURL = opts.baseURL.replace(/\\/$/, '');\n  const datastore: ClientDatastore = opts.datastore ?? createMemoryDatastore();\n  const realtime = opts.realtime ?? 'sse';\n\n  async function post(path: string, body: unknown) {\n    const res = await fetch(`${baseURL}${path}`, { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify(body) });\n    if (!res.ok) throw new Error(`HTTP ${res.status}`);\n    return res.json();\n  }\n\n  function table(name: string) {\n    return {\n      async select(pkOrQuery: PrimaryKey | SelectRequest) {\n        if (typeof pkOrQuery === 'string' || typeof pkOrQuery === 'number' || (pkOrQuery && typeof pkOrQuery === 'object' && !('table' in pkOrQuery))) {\n          const row = await datastore.readByPk(name, pkOrQuery as PrimaryKey);\n          if (row) return row;\n          const res: SelectResponse = await post('/select', { table: name, where: undefined, select: undefined, orderBy: { updatedAt: 'desc' }, limit: 1 });\n          return res.data[0] ?? null;\n        }\n        const req = pkOrQuery as SelectRequest;\n        const res: SelectResponse = await post('/select', { ...req, table: name });\n        return res;\n      },\n      async insert(row: Record<string, unknown>) {\n        // optimistic apply with temp id\n        const clientOpId = ulid();\n        const tempId = `temp_${clientOpId}`;\n        await datastore.apply(name, tempId, { set: row });\n        try {\n          const res: any = await post('/mutate', { op: 'insert', table: name, rows: row, clientOpId });\n          const inserted = (res.row ?? (res.rows && res.rows[0])) as Record<string, unknown> & { version: number };\n          await datastore.reconcile(name, (inserted as any).id ?? tempId, inserted);\n          return inserted;\n        } catch (e) {\n          await datastore.apply(name, tempId, { unset: Object.keys(row) });\n          throw e;\n        }\n      },\n      async update(pk: PrimaryKey, set: Record<string, unknown>, opts?: { ifVersion?: number }) {\n        const clientOpId = ulid();\n        await datastore.apply(name, pk, { set });\n        try {\n          const res: any = await post('/mutate', { op: 'update', table: name, pk, set, ifVersion: opts?.ifVersion, clientOpId });\n          const row = res.row as Record<string, unknown> & { version: number };\n          await datastore.reconcile(name, pk, row);\n          return row;\n        } catch (e) {\n          // best-effort rollback: not tracking previous value in MVP\n          throw e;\n        }\n      },\n      async delete(pk: PrimaryKey) {\n        const clientOpId = ulid();\n        await datastore.apply(name, pk, { unset: ['__deleted__'] });\n        try {\n          await post('/mutate', { op: 'delete', table: name, pk, clientOpId });\n          return { ok: true } as const;\n        } catch (e) {\n          throw e;\n        }\n      },\n      async upsert(rowOrRows: any, options?: { merge?: string[] }) {\n        const rows = Array.isArray(rowOrRows) ? rowOrRows : [rowOrRows];\n        const clientOpId = ulid();\n        for (const r of rows) {\n          const pk = (r && (r.id ?? r)) as PrimaryKey;\n          await datastore.apply(name, pk, { set: r });\n        }\n        const res: any = await post('/mutate', { op: 'upsert', table: name, rows, merge: options?.merge, clientOpId });\n        const payload = res.rows ?? [res.row];\n        for (const r of payload as Array<Record<string, unknown> & { version: number }>) {\n          await datastore.reconcile(name, (r as any).id, r);\n        }\n        return Array.isArray(rowOrRows) ? payload : payload[0];\n      },\n      watch(pkOrQuery: PrimaryKey | SelectRequest, cb: (arg: any) => void) {\n        const state = { status: 'connecting' as 'connecting' | 'live' | 'retrying', error: undefined as any, snapshot: null as any };\n        let es: EventSource | null = null;\n        let stopped = false;\n        const base = baseURL;\n        const startSse = () => {\n          es = new EventSource(`${base}/events`);\n          es.onopen = () => { state.status = 'live'; };\n          es.onerror = () => { state.status = 'retrying'; };\n          es.onmessage = async (ev) => {\n            try {\n              const data = JSON.parse(ev.data);\n              // naive: on any event for this table, refresh\n              const res = await post('/select', typeof pkOrQuery === 'object' && 'table' in (pkOrQuery as any) ? pkOrQuery : { table: name });\n              state.snapshot = res;\n              cb(res);\n            } catch {}\n          };\n        };\n        if (realtime === 'sse') startSse();\n        else if (realtime === 'poll') {\n          const iv = setInterval(async () => {\n            if (stopped) return clearInterval(iv);\n            const res = await post('/select', typeof pkOrQuery === 'object' && 'table' in (pkOrQuery as any) ? pkOrQuery : { table: name });\n            cb(res);\n          }, opts.pollIntervalMs ?? 1500);\n        }\n        return {\n          unsubscribe() {\n            stopped = true;\n            if (es) es.close();\n          },\n          get status() { return state.status; },\n          get error() { return state.error; },\n          getSnapshot() { return state.snapshot; },\n        };\n      },\n    };\n  }\n\n  const client: any = new Proxy({}, {\n    get(_t, prop) {\n      if (prop === 'mutators') {\n        return new Proxy({}, {\n          get(_t2, name) {\n            return async (args: unknown) => post(`/mutators/${String(name)}`, { args });\n          }\n        });\n      }\n      return table(String(prop));\n    }\n  });\n  return client as any;\n}\n\n// Minimal in-memory datastore for MVP\nexport function createMemoryDatastore(): ClientDatastore {\n  type Canon = string;\n  const store = new Map<string, Map<Canon, any>>();\n  function canon(pk: PrimaryKey): Canon {\n    if (typeof pk === 'string' || typeof pk === 'number') return String(pk);\n    return Object.keys(pk).sort().map((k) => `${k}=${String((pk as any)[k])}`).join('|');\n  }\n  function ensure(table: string) { if (!store.has(table)) store.set(table, new Map()); return store.get(table)!; }\n  return {\n    async apply(table, pk, diff) {\n      const m = ensure(table);\n      const key = canon(pk);\n      const current = m.get(key) ?? {};\n      if (diff.set) Object.assign(current, diff.set);\n      if (diff.unset) for (const f of diff.unset) delete current[f];\n      m.set(key, current);\n    },\n    async reconcile(table, pk, row) {\n      const m = ensure(table);\n      const key = canon(pk);\n      const existing = m.get(key);\n      if (!existing || typeof existing.version !== 'number' || row.version >= existing.version) {\n        m.set(key, row);\n      }\n    },\n    async readByPk(table, pk) {\n      const m = ensure(table);\n      return m.get(canon(pk)) ?? null;\n    },\n    async readWindow(table, req) {\n      const m = ensure(table);\n      const data = Array.from(m.values());\n      return { data, nextCursor: null };\n    }\n  };\n}\n\n"],"mappings":"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","names":["res","opts"]}